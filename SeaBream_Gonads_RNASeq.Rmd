---
title: "DEG in Gilthead sea bream Gonads"
author: "Camille Bordes, bordescamille@duck.com"
date: "version `r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---


```{r setup, include=FALSE, message=FALSE, echo=FALSE}
#seed <- sample(1:10000, 1)
# devtools::install_github('kevinblighe/EnhancedVolcano')
# devtools::install_github("yanlinlin82/ggvenn")

set.seed(927)
x <- c("openxlsx", "dplyr", "tidyverse", "tximport", "preprocessCore", "impute",  # data manipulation
       "BiocManager", "AnnotationHub", "biomaRt", "ensembldb", "GO.db",           # gene annotation
       "RColorBrewer", "ggplot2", "ggrepel", "enrichplot", "pheatmap", "treemap", # data visualization
       "DESeq2", "edgeR", "limma", "pathview", "WGCNA", "drlib",
       "DOSE", "clusterProfiler", "GOstats", "gProfileR", "gage", "gageData")
lapply(x, require, character.only = TRUE)

setwd(dir = "/Users/bordescamille/Desktop/Tilapia Project/DEanalysis/DEanalysis/")
data0 <- openxlsx::read.xlsx("data/For network_camille.xlsx", sheet = 1, startRow = 1) 
data  <- data0 %>%
  textshape::column_to_rownames(loc = 1) %>%
  dplyr::select(c(1:18))

meta <- expand_grid(c(1:6), c(1:3)) %>% as.data.frame()
meta <- meta[order(meta$Var1),]
colnames(meta) <- c("stage", "replicates")
rownames(meta) <- paste(meta$stage, meta$replicates, sep = "_")

meta$replicates <- as.factor(meta$replicates)
```


# RNA-seq data 

The provided dataset comprises gene expression counts obtained from **RNA-seq analysis of Gilthead sea bream gonads**. The matrix contains information on **`r dim(data)[1]` genes** across **`r dim(data)[2]` samples**, each representing a distinct gonadal tissue sample obtained from **three biological replicates across 6 stages of development.** The average gene count across all samples is **408.3001**, indicating the expression level of genes in the dataset. The standard deviation of **1069.982** highlights the variability in gene expression, and the range, spanning from **0 to 44281**, underscores the diversity in expression counts across the examined genes. This dataset serves as a valuable resource for investigating the molecular dynamics associated with Gilthead sea bream gonadal development, offering insights into the gene expression patterns that characterize different developmental stages.

<br>
<br>

***

<br>
<br>

## Data mining {.tabset}

### Data normalization and log-correction

First we visualize the gene counts after simple normalization, the point being to ensure that all the samples have comparable gene counts.

```{r, message=FALSE, echo=FALSE, warning=FALSE, fig.width=10}
data <- round(data)
dds  <- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ stage)
dds  <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized = TRUE)

rld_mat2 <- normalized_counts %>%
  as.matrix() %>%
  reshape2::melt() %>%
  dplyr::mutate(stage     = stringr::str_extract(Var2, pattern = "[1-6]{1}"),
                replicate = stringr::str_extract(Var2, pattern = "(?<=_)[1-6]{1}"))
rld_mat2$value <- log(rld_mat2$value)

ggpubr::ggsummarystats(
  rld_mat2, 
  x = "stage", 
  y = "value", 
  ggfunc  = ggpubr::ggviolin, 
  add     = c("jitter"), 
  color   = "replicate", 
  palette = "npg")
```

<br>
<br>

***

<br>
<br>

### Average gene expression

In our investigation, we explore the impact of developmental stages on average gene expression. Our findings reveal a distinctive pattern: a subset of genes sampled in the gonads exhibits high expression levels during the initial two stages but experiences down-regulation as the gonads continue to develop. Conversely, the remaining portion of the gene population demonstrates relatively low expression in stages 1 and 2, progressively up-regulating as the gonads mature. We observe a pivotal intermediate stage (stage 3) when this transition occurs (on average).

```{r, message=FALSE, echo=FALSE, fig.width=10}
rld     <- rlog(dds, blind = TRUE)
rld_mat <- assay(rld)

rld_mat2 <- rld_mat %>%
  as.matrix() %>%
  reshape2::melt() %>%
  dplyr::mutate(stage     = stringr::str_extract(Var2, pattern = "[1-6]{1}"),
                replicate = stringr::str_extract(Var2, pattern = "(?<=_)[1-6]{1}")) %>%
  dplyr::group_by(Var1, stage) %>%
  dplyr::summarise(avgExpr = mean(value, na.rm = TRUE)) %>%
  dplyr::ungroup() %>%
  reshape2::acast(Var1 ~ stage)
rownames(rld_mat2) <- NULL

pheatmap(rld_mat2, 
         cluster_cols = FALSE, 
         scale        = "row",
         border_color = "black",
         main = "Average gene expression per developmental stage")
```

<br>
<br>

***

<br>
<br>

### Correlation between samples

We also investigate how the different samples behave in comparison to each other to identify outliers or aberrant samples. To do so, we build the correlation plot between every sample pair. Sudden drops in correlation coefficients might indicate technical issues or sample outliers, while clusters of samples with high correlations may suggest common biological characteristics or batch effects.

```{r, message=FALSE, collapse=TRUE, echo=FALSE, fig.width=10}
rld_cor <- cor(rld_mat)
pheatmap(rld_cor, 
         border_color = NA, 
         fontsize     = 10, 
         fontsize_row = 10, 
         height       = 20,
         main = "Similarity in expression patterns across samples")
```

<br>
<br>

***

<br>
<br>

## Initial Quality control 

### Regular PCA {.tabset}

#### 2 principal components

The PCA performed on normalized gene counts show that the different samples mostly cluster per developmental stages. 
**Stages 1, 2, and 3:** They present very different clusters which suggest a strong change in gene expression during these first stages. 
**Stages 4, 5, and 6:** They cluster closer together which suggests there are less changes happening during these last stages of gonads developments.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
pca <- normalized_counts %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
P1  <- summary(pca)$importance
df  <- cbind(meta, pca$x)

ggplot(df, 
       aes(x = PC1, 
           y = PC2, 
           color = as.factor(stage)))  + 
  geom_point() + 
  ylab(paste0("PC1: ", round(P1[2,1]*100, digits = 2), "%")) +
  xlab(paste0("PC2: ", round(P1[2,2]*100, digits = 2), "%")) +
  ggthemes::theme_few()
```

<br>
<br>

#### 3 principal components

We extend the plot to the third PC axis of the PCA. One sample in the first developmental stage is slightly away from the rest of its cohort. It could be an asynchronous sample which already experiences some changes in gonad development. A similar pattern can be observed in the 5th development stage. Since we have only 3 biological duplicates per stage, we cannot conclude to any significant outlier.

```{r, message=FALSE, echo=FALSE, fig.width=8}
pca <- normalized_counts %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()

df  <- cbind(meta, pca$x)
plotly::plot_ly(data = df,
                x = ~PC1,
                y = ~PC2,
                z = ~PC3,
                color = ~ stage,
                type  = "scatter3d")
```

<br>
<br>

### Generalised PCA {.tabset}

Given that the data are heavily skewed into a heavily-tail distribution, a regular PCA maybe present slightly distorted projections and make it look as though some point strongly diverge from their cluster as an artifact of skewed gene counts. Hence we also perform a Generalized PCA using a Negative Binomial distribution with feature-specific over dispersion to gain further insights into our data.

#### Samples

```{r, message=FALSE, echo=FALSE, warning=FALSE}
gpca <- glmpca::glmpca(normalized_counts, 2, fam = "nb2")
gpca.dat <- gpca$factors %>%
  tibble::rownames_to_column(var = "sampleID") %>%
  dplyr::mutate(stage = stringr::str_extract(sampleID, "[1-6]{1}"),
                replicates = stringr::str_extract(sampleID, pattern = "(?<=_)[1-6]{1}"))

pglmpca <- ggplot(gpca.dat, 
  aes(x = dim1, 
      y = dim2, 
      color = stage, 
      label = replicates)) +
  geom_point(size = 3) + 
  coord_fixed() +
  scale_color_viridis_d() +
  ggpubr::theme_pubclean()

plotly::ggplotly( pglmpca )
```
We retrieve the behavior displayed in the correlation heatmap where stages 1 and 2 cluster separately whereas stage 3 clusters closer to stages 4, 5, and 6. Furthermore, we find that samples 1_3, 3_3, and 5_2 stand aside from the other samples in there respective developmental stages. Given the sample size, we cannot determine whether these samples are real outliers, hence we do not remove these points but head towards a weighted differential gene expression analysis.  

<br>
<br>

***

<br>
<br>

#### Genes

We also perform the GPCA on the genes to investigate whether they cluster into different groups, which can sometimes hint at patterns into the coming DEG analysis.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gpca.dat <- gpca$loadings %>%
  tibble::rownames_to_column(var = "geneID")

pglmpca <- ggplot(gpca.dat, 
  aes(x = dim1, 
      y = dim2,
      label = geneID)) +
  geom_point(size = 3) + 
  coord_fixed() +
  scale_color_viridis_d() +
  ggpubr::theme_pubclean()

plotly::ggplotly( pglmpca )
```
  
<br>
<br>

***

<br>
<br>

## Outlier detection {.tabset}

### Rare genes

We further check the gene list for rare genes which expression could bias the overall differential expression analysis: most **rare genes were already filtered out** of the data set and no further filtering is necessary.

```{r, message=FALSE, warning=FALSE, echo = FALSE}
ensembl <- useEnsembl(biomart = "ensembl", dataset = "saurata_gene_ensembl") #version "fSpaAur1.1"
genes   <- rbind.data.frame(
  getBM(attributes = c("ensembl_gene_id", "ensembl_transcript_id", "go_id",
                        "hgnc_symbol", "hgnc_id", "entrezgene_id", "external_gene_name", "description"),
        filters    = "ensembl_gene_id",
        values     = data0$Id,
        mart       = ensembl),
  getBM(attributes = c("ensembl_gene_id", "ensembl_transcript_id", "go_id",
                       "hgnc_symbol", "hgnc_id", "entrezgene_id", "external_gene_name", "description"),
        filters    = "external_gene_name",
        values     = data0$`DEG.with.>2000.total.reads`,
        mart       = ensembl),
  getBM(attributes = c("ensembl_gene_id", "ensembl_transcript_id", "go_id",
                       "hgnc_symbol", "hgnc_id", "entrezgene_id", "external_gene_name", "description"),
        filters    = "hgnc_symbol",
        values     = data0$`DEG.with.>2000.total.reads`,
        mart       = ensembl))

key <- genes %>% 
  dplyr::select(ensembl_gene_id, external_gene_name) %>%
  dplyr::filter(ensembl_gene_id %in% rownames(data)) %>%
  dplyr::distinct() %>%
  dplyr::arrange(external_gene_name)

# Checking that my mapping is same as Elena's
#hgn1 <- data0$`DEG.with.>2000.total.reads`
#hgn2 <- key$external_gene_name
#lls <- match(data0$Id, key$ensembl_gene_id)
#cbind(Elena = hgn1[hgn1!=hgn2[lls]], Camille = hgn2[lls][hgn1!=hgn2[lls]])

dat.filtered <- DGEList(
  counts  = as.matrix(data),
  samples = meta,
  genes   = key
)

QC_weights <- voomWithQualityWeights(
  counts    = dat.filtered, 
  design    = model.matrix(~stage, data = dat.filtered$samples),
  block     = dat.filtered$samples$replicates,
  plot      = FALSE, save.plot = TRUE)

data.frame(x = QC_weights$voom.xy$x,
           y = QC_weights$voom.xy$y,
           linex = QC_weights$voom.line$x,
           liney = QC_weights$voom.line$y) %>%
  ggplot() +
  geom_point(aes(x = x,
                 y = y),
             color = "grey50",
             alpha = .5) +
  geom_line(aes(x = linex,
                y = liney),
            color = "tomato") +
  ggplot2::ggtitle("VoomQW: Mean-variance trend") +
  xlab("log2(count + 0.5)") +
  ylab("√(Std deviation)") +
  ggpubr::theme_pubclean()
```

```{r, echo=FALSE}
source("https://raw.githubusercontent.com/kdillmcfarland/R_bioinformatic_scripts/master/RNAseq_rare_gene_filter.R")
rare.gene.filter(dat = dat.filtered,
                 gene.var = colnames(dat.filtered$genes)[1],
                 min.pct  = 20,  # which percentage of samples need to have a non-zero count?
                 min.CPM  = 100,  # what is the minimal gene count required for each gene in each sample?
                 name = "dat.abund")

#voomWithQualityWeights(
#  counts    = dat.abund, 
#  design    = model.matrix(~stage, data = dat.abund$samples),
#  plot      = TRUE)
```

<br>
<br>

***

<br>
<br>
  
### Sample quality

After filtering out potentially rare genes, we standardize gene expression and re-run a VOOM analysis to determine sample quality: **sample 5_2 should be given less weight** in the differential gene expression analysis than other samples. As highlighted in the QC before, sample 5_2 displayed a slightly different behavior compared to other replicates in the 5th developmental stage. It could be that this individual have either more advanced or delayed gonad development compared to the animals sampled along them. The VOOM analysis also detects samples from developmental stages 1 and 3 as potentially weak samples. This is expected as these two developmental stages show about 2/3 of their genes being little expressed in the heat map presented before. Compared to other developmental stages where more genes become highly expressed, these samples seem to be of poor quality but it is a by-product of the time dependency.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
dat.abund.norm  <- calcNormFactors(dat.abund)
dat.abund.norm$samples$replicates <- as.factor(dat.abund.norm$samples$replicates)
QC.weights.voom <- voomWithQualityWeights(
  counts    = dat.abund.norm, 
  design    = model.matrix(~stage, data = dat.abund.norm$samples),
  block     = dat.abund.norm$samples$replicates,
  plot      = FALSE, save.plot = TRUE)

QC.weights.voom$targets %>%
  ggplot(aes(x = stage,
             y = sample.weights,
             fill = as.factor(replicates))) +
  geom_bar(position = "dodge", 
           stat     = "identity") +
  geom_hline(aes(yintercept = 1), 
             color = "darkred", 
             lty = "dotdash") +
  scale_fill_viridis_d() +
  ggpubr::theme_pubclean() +
  ylab("Sample Quality Weight") +
  xlab("Developmental stage")
```

Note that if we remove the time-dependence (by transforming the stage variable into a factor), the first two stages no longer are detected as weak samples. Instead, samples 1_3, 3_3, and 5_2 (which were already identified as deviant in the GPCA) stand out as poor quality samples.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
dat.abund.bis <- dat.abund.norm
dat.abund.bis$samples$stage <- as.factor(dat.abund.bis$samples$stage)

QC.weights.bis <- voomWithQualityWeights(
  counts    = dat.abund.bis, 
  design    = model.matrix(~stage, data = dat.abund.bis$samples),
  block     = dat.abund.bis$samples$replicates,
  plot      = FALSE, save.plot = TRUE)

QC.weights.bis$targets %>%
  ggplot(aes(x = stage,
             y = sample.weights,
             fill = as.factor(replicates))) +
  geom_bar(position = "dodge", 
           stat     = "identity") +
  geom_hline(aes(yintercept = 1), 
             color = "darkred", 
             lty = "dotdash") +
  scale_fill_viridis_d() +
  ggpubr::theme_pubclean() +
  ylab("Sample Quality Weight") +
  xlab("Developmental stage")
```
<br>
<br>

***

<br>
<br>
  
# Differential Gene Expression Analysis {.tabset}
*(With repeated measures design)*

## LIMMA-VOOM analysis

The LIMMA approach relies on linear Bayesian models to approximate the effect of the development stage on sea bream gene expressions. It also applies quantile normalization to account for differences in gene expression across samples and controls for stage-dependent variance in gene expression.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
QC.weights.voom$targets$replicates <- as.factor(QC.weights.voom$targets$replicates)
model <- model.matrix(~stage, data = QC.weights.voom$targets)
consensus.corr <- duplicateCorrelation(
  object = QC.weights.voom$E,
  block  = QC.weights.voom$targets$replicates,
  design = model)
```
The average correlation between genes from samples originating from the same biological replicates is **`r consensus.corr$consensus.correlation`**. We run a differential gene expression analysis per block while accounting for the correlation between genes across developmental stages.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
fit <- lmFit(
  object = QC.weights.voom$E,
  block  = QC.weights.voom$targets$replicates,
  design = model,
  correlation = consensus.corr$consensus.correlation,
  robust = TRUE)
efit <- eBayes(fit)

res <- topTable(
  fit    = efit,
  number = nrow(QC.weights.voom),
  adjust.method = "BH")

summary(decideTests(efit, lfc = 0.58, p.value = 0.05))
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 10}
res$Gene.symbol <- data0$`DEG.with.>2000.total.reads`[match(rownames(res), data0$Id)]
res$Gene.symbol[res$Gene.symbol=="0"] <- NA

EnhancedVolcano::EnhancedVolcano(res,        
  x        = 'logFC',
  y        = 'P.Value',
  pCutoff  = 0.01,
  FCcutoff = 1.5,
  lab      = res$Gene.symbol,
  title    = "Differential expression (VOOM)",
  subtitle = "Sea bream - Gonadal development",
  caption  = bquote("Lfc cutoff: 1.5, P-val cutoff: 0.01"),
  legendPosition = "bottom")
```


```{r, message=FALSE, warning=FALSE, echo=FALSE}
as.data.frame(res)
```

<br>
<br>

***

<br>
<br>

## DESeq2 analysis

```{r, echo=FALSE, warning=FALSE, message=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = data, 
  colData   = meta, 
  design    = ~ stage)
dds   <- DESeq(dds, test = "LRT", reduced = ~1)
resTC <- results(dds, alpha = 0.05, cooksCutoff=FALSE)
resTC$symbol <- mcols(dds)$symbol
res_shrunken <- lfcShrink(dds, 
  coef = "stage", 
  res  = resTC, 
  type = "normal")

res <- dds %>% results(alpha = 0.05) %>% summary()
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
#plotDispEsts(dds)

W        <- res_shrunken$stat
idx      <- !is.na(W)
maxCooks <- apply(assays(dds)[["cooks"]], 1, max)

plot(rank(W[idx]), 
     maxCooks[idx], 
     xlab = "rank of Wald statistic", 
     ylab = "maximum Cook's distance per gene",
     main = "Checking for gene outliers",
     ylim = c(0,5), 
     cex  = .4, 
     col  = rgb(0, 0, 0, .3))

m <- ncol(dds)
p <- 2
abline(h = qf(.99, p, m - p))
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 10}
res_shrunken <- res_shrunken %>% 
  as.data.frame() %>%
  tibble::rownames_to_column(var = "gene") %>%
  dplyr::mutate(geneName = data0$`DEG.with.>2000.total.reads`[match(gene, data0$Id)])
res_shrunken$geneName[res_shrunken$geneName=="0"] <- NA

EnhancedVolcano::EnhancedVolcano(res_shrunken,        
  x        = 'log2FoldChange',
  y        = 'padj',
  pCutoff  = 0.01,
  FCcutoff = 1.5,
  lab      = res_shrunken$geneName,
  title    = "Differential expression (DESeq2)",
  subtitle = "Sea bream - Gonadal development",
  caption  = bquote("Lfc cutoff: 1.5, P-val cutoff: 0.01"),
  legendPosition = "bottom")
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
as.data.frame(res_shrunken)
```

<br>
<br>

***

<br>
<br>

## Agreement between analyses

Whether we use the LIMMA-VOOM or the DESeq method will affect the panel of genes detected as differentially expressed across developmental stage. Both methods fully agree on the set of genes that are down-regulated as gonads develop but disagreements occur when analyzing which genes are up-regulated and which ones are non-significant.

For instance, 14 genes were detected to be upregulated by the DESeq analysis but were non-significant in the LIMMA-VOOM. And 22 genes were found to be upregulated by the LIMMA-VOOM analysis but were non-significant in the DESeq analysis.

***Feel free to go through the list of genes, see if there are problematic results between the two models, or if one analysis is more interesting for your project than the other.***

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 10}
lim.res <- as.data.frame(decideTests(efit, lfc = 0.58, p.value = 0.05))
gen.lim <- rownames(lim.res[lim.res$stage!=0,])
gen.des <- rownames(resTC[resTC$pvalue<0.05 & abs(resTC$log2FoldChange>0.58),])
agreement <- data.frame(
  genes = union(gen.lim, gen.des),
  limma = "Non significant",
  DESeq = "Non significant")
agreement$HGNC  <- data0$`DEG.with.>2000.total.reads`[match(agreement$genes, data0$Id)]
agreement$HGNC[agreement$HGNC == "0"] <- agreement$genes[agreement$HGNC == "0"]
agreement$DESeq[agreement$genes %in% rownames(resTC[resTC$pvalue<0.05 & resTC$log2FoldChange<0,])] <- "down-regulated"
agreement$DESeq[agreement$genes %in% rownames(resTC[resTC$pvalue<0.05 & resTC$log2FoldChange>0,])] <- "up-regulated"
agreement$limma[agreement$genes %in% rownames(lim.res[lim.res$stage == (-1),])] <- "down-regulated"
agreement$limma[agreement$genes %in% rownames(lim.res[lim.res$stage == (1),])]  <- "up-regulated"
agreement$`The analyses...` <- c("disagree", "agree")[1 + as.numeric(agreement$limma==agreement$DESeq)]
agreement <- agreement[order(agreement$`The analyses...`),]

compareAnalyses <- list(
  LIMMA_NonSig      = unlist(agreement$HGNC[agreement$limma=="Non significant"]),
  LIMMA_UpRegulated = unlist(agreement$HGNC[agreement$limma=="up-regulated"]),
  DESeq_UpRegulated = unlist(agreement$HGNC[agreement$DESeq=="up-regulated"]),
  DESeq_NonSig      = unlist(agreement$HGNC[agreement$DESeq=="Non significant"])
  #LIMMA_DownRegulated  = unlist(agreement$HGNC[agreement$limma=="down-regulated"]),
  #DESeq_DownRegulated  = unlist(agreement$HGNC[agreement$DESeq=="down-regulated"])
)

ggvenn::ggvenn(compareAnalyses, 
  fill_color    = c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF"),
  stroke_size   = 0.5, 
  set_name_size = 4)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
as.data.frame(agreement)
```

<br>
<br>

***

<br>
<br>

# Gene annotation

Genes were annotated using the NCBI database ("ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/"), version "fSpaAur1.1".
```{r, echo=FALSE, message=FALSE, warning=FALSE}
ah     <- AnnotationHub::AnnotationHub()
orgdbs <- AnnotationHub::query(ah, c("Sparus aurata", "OrgDb"))
sparus_aurata_orgdb <- ah[[orgdbs$ah_id[1]]]

ggg <- readRDS(file = "~/Desktop/combined_annotations_Saurata_11223.rds")
colnames(ggg) <- c("ensembl_gene_id", "entrezgene_id", "external_gene_name", "hgnc_symbol", "description")
genes <- plyr::rbind.fill(genes, ggg) %>% dplyr::filter(!duplicated(.))

sparus_aurata_orgdb
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
padj.cutoff <- 0.05
lfc.cutoff  <- 0.58 # log2(1.5) = 0.5849625

idx <- (genes$ensembl_gene_id %in% res_shrunken$gene)
ids <- genes[idx, ]
ids <- ids[which(duplicated(ids) == FALSE),]

res_ids <- inner_join(res_shrunken, ids, by = c("gene" = "ensembl_gene_id"))
mis_gen <- setdiff(res_ids$gene, res_ids$gene[!is.na(res_ids$entrezgene_id)])

res_ids$initial_desc <- data0$X20[match(res_ids$gene, data0$Id)]
lls <- which(res_ids$description != res_ids$initial_desc)
mis <- unique(res_ids[lls, c("description", "initial_desc")])

sigDE <- res_ids %>% dplyr::filter(padj < padj.cutoff & abs(log2FoldChange) > lfc.cutoff)
lls <- match(as.character(sigDE$gene), res_ids$gene)
allDE_genes <- unique(res_ids$entrezgene_id)
sigDE_genes <- unique(res_ids$entrezgene_id[lls])
sigDE_up    <- unique(res_ids$entrezgene_id[intersect(lls, which(res_ids$log2FoldChange>0))])
sigDE_do    <- unique(res_ids$entrezgene_id[intersect(lls, which(res_ids$log2FoldChange<0))])
```

<br>
<br>

***

<br>
<br>

# Gene Co-expression Network

### Building the co-expression network

```{r, message=FALSE, warning=FALSE, echo=FALSE}
cor       <- WGCNA::cor
datExpr   <- t(normalized_counts)

powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
invisible(
  capture.output(
    sft    <- pickSoftThreshold(
            datExpr,
            powerVector = powers,
            verbose = 5)
  )
)

par(mfrow = c(1,2))
cex1 = 0.9
plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence"))
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red")
abline(h = 0.60, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
softPower <- 10
subExpr   <- datExpr[,colnames(datExpr) %in% sigDE$gene]
dissTOM   <- 1 - TOMsimilarityFromExpr(subExpr, power = softPower, networkType = "unsigned")

geneTree    <- hclust(as.dist(dissTOM), method = "average")
dynamicMods <- cutreeDynamic(
  dendro            = geneTree, 
  distM             = dissTOM,
  deepSplit         = 2, 
  pamRespectsDendro = FALSE,
  minClusterSize    = 10)
dynamicColors <- labels2colors(dynamicMods)

MEList <- moduleEigengenes(subExpr, colors = dynamicColors)
MEs    <- MEList$eigengenes
MEDiss <- 1 - cor(MEs)
METree <- hclust(as.dist(MEDiss), method = "average")

MEDissThres <- 0.0
merge <- mergeCloseModules(subExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
mergedColors <- merge$colors
mergedMEs    <- merge$newMEs
moduleColors <- mergedColors
colorOrder   <- c("grey", standardColors(50))
moduleLabels <- match(moduleColors, colorOrder)-1
MEs <- mergedMEs

moduleMembership <- data.frame(
  GeneId = colnames(subExpr),
  Module = mergedColors)

dat <- subExpr %>%
  as.data.frame() %>% 
  t() %>%
  reshape2::melt() %>%
  dplyr::mutate(stage         = stringr::str_extract(Var2, pattern = "[1-6]{1}"),
                replicates    = stringr::str_extract(Var2, pattern = "(?<=_)[1-6]{1}"),
                coExpr.module = moduleMembership$Module[match(Var1, moduleMembership$GeneId)]) %>%
  dplyr::rename("gene" = "Var1", "sample" = "Var2")

MEs0 <- moduleEigengenes(subExpr, mergedColors)$eigengenes
MEs0 <- orderMEs(MEs0)
module_order <- names(MEs0) %>% gsub("ME","", .)
MEs0$treatment <- row.names(MEs0)
mME <-MEs0 %>%
  pivot_longer( - treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order))
```

<br>
<br>

### Co-expressed genes  {.tabset}

Genes are grouped based on how similarly they are expressed across developmental stages. The grouping relies on a simple hierarchical clustering algorithm and the optimal partition was determined using the dynamic modularity algorithm (PART). Among all the genes which expression levels changed as gonads developed, 8 trends can be identified (i.e., modules of co-expression). We provide a heat map and a graph-like representation of the co-expression network. In the graph, we represent the minimal spanning tree of the co-expression modules separately.

#### Network heatmap

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width = 10}
plotTOM       <- dissTOM ^ 3
diag(plotTOM) <- NA
TOMplot(plotTOM, geneTree, dynamicColors, main = "Network heatmap plot (sig only)")
```

<br>
<br>

#### Network graph

```{r, echo = FALSE, warning=FALSE, message=FALSE}
library(igraph)
for (mm in unique(moduleMembership$Module)) {
  
  genes_of_interest <- moduleMembership %>% subset(Module %in% mm)
  expr_of_interest  <- normalized_counts[rownames(normalized_counts) %in% genes_of_interest$GeneId,]
  invisible(
    capture.output(
      TOM <- (1 - TOMsimilarityFromExpr(t(expr_of_interest), power = softPower))
    )
  )
  lls               <- match(genes_of_interest$GeneId, data0$Id)
  row.names(TOM)    <- data0$`DEG.with.>2000.total.reads`[lls]
  colnames(TOM)     <- data0$`DEG.with.>2000.total.reads`[lls]
  n                 <- which(row.names(TOM)=="0")
  row.names(TOM)[n] <- colnames(TOM)[n] <- paste0("UnID_", c(1:length(n)))
  diag(TOM)         <- NA
  
  graph <- igraph::graph_from_adjacency_matrix(TOM, mode = "undirected", weighted = TRUE)
  graph <- igraph::delete.vertices(igraph::simplify(graph), igraph::degree(graph)==0)
  
  V(graph)$IDs   <- data0$Id[lls]
  V(graph)$color <- moduleMembership$Module[match(V(graph)$IDs, moduleMembership$GeneId)]
  V(graph)$FCs   <- sigDE$log2FoldChange[match(V(graph)$IDs, sigDE$gene)]
  
  mst <- mst(graph, weights = E(graph)$weights, algorithm = "prim")
  mst <- igraph::delete.vertices(igraph::simplify(mst), igraph::degree(mst)==0)
  lay <- layout.fruchterman.reingold(mst)
  
  plot(mst, 
             layout       = lay,
             edge.curved  = TRUE,
             label.cex    = 0,
             vertex.label = NA,
             #vertex.size  = 2+LDATS::softmax(exp(abs(V(graph)$FCs)*1))*100,
             vertex.size  = exp(abs(V(graph)$FCs)*1.5),
             vertex.shape = c("circle", "", "square")[sign(V(graph)$FCs)+2],
             vertex.color = V(graph)$color)
  
}
```

<br>
<br>

###  Characteristics of modules of co-expression {.tabset}

#### Modules vs. samples

For each sample in the study, we determine if one or several blocks of co-expressed genes are particularly represented. All samples collected during stages 1 and 2 show a strong expression of genes belonging to the modules "blue" and "pink". Samples collected during the 3rd developmental stage display a lower expression of these two modules and a slightly higher expression of all other modules of co-expressed genes. Finally, samples collected later during the development of the gonads show a low expression of genes belonging to the "pink" and "blue" modules and a strong expression of all other modules. The 3rd developmental stage appears to be a transition between stages 1 and 2, on the one hand, and stages 4, 5, and 6 on the other hand. Stages 4,5, and 6, show similar gene expression patterns, suggesting a stabilization of gene expression during these stages.

*As detected before, sample 5_2 shows a divergent trend in gene expression.*

```{r, message=FALSE, warning=FALSE, echo=FALSE}
mME %>% ggplot(., aes(x = treatment, y = name, fill = value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Expression of modules of co-expressed genes per sample", y = "Modules", fill = "corr")
```

<br>
<br>

***

<br>
<br>

#### Modules vs. Samples characteristics

We investigate how the temporal trend in gene expression in each module of co-expressed genes correlates with sample characteristics.  
-- **No effects of the biological replicates**  
-- **Down-regulation of genes in modules "blue" and "pink"**  
-- **Up-regulation of genes in all other modules**  

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.height=6}
datTraits <- meta
nGenes   <- ncol(subExpr)
nSamples <- nrow(subExpr)
MEs0     <- moduleEigengenes(subExpr, mergedColors)$eigengenes
MEs      <- orderMEs(MEs0)

moduleTraitCor    <- cor(MEs, datTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(p = ",
                    signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) <- dim(moduleTraitCor)
dimnames(textMatrix) <- dimnames(moduleTraitPvalue)
textMatrix <- textMatrix %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Module") %>%
  tidyr::pivot_longer(cols = c(2,3),
                      names_to = "Trait",
                      values_to = "Label")

moduleTraitCor <- moduleTraitCor %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "Module") %>% 
  tidyr::pivot_longer(cols      = c(2,3), 
                      names_to  = "Trait", 
                      values_to = "Correlation") %>%
  dplyr::left_join(y = textMatrix,
                   by = c("Module", "Trait")) %>%
  dplyr::arrange(Correlation) %>%
  dplyr::mutate(Module = fct_inorder(factor(Module, ordered = TRUE)))

p <- ggplot(data = moduleTraitCor,
 aes(x = Trait, 
     y = Module, 
     fill = Correlation)) +
  geom_tile(alpha = .8, color = "grey40") +
  geom_text(aes(label = Label)) +
  scale_fill_gradient2(low  = "green", 
                       mid  = "lightyellow", 
                       high = "red") +
  ggpubr::theme_pubclean() +
  xlab("Samples characteristics") +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank())

ylabs <- ggplot_build(p)$layout$panel_params[[1]]$y$get_labels()
legendMat <- data.frame(
    Module = unique(moduleTraitCor$Module), 
    Correl = unique(moduleTraitCor$Correlation)) %>%
  dplyr::arrange(Correl) %>%
  dplyr::mutate(Module = fct_inorder(factor(Module, ordered = TRUE)),
                value  = stringr::str_remove(Module, "ME"))

clu <- ggplot(data = legendMat,
       aes(x = 1, y = Module, fill = value)) +
  geom_tile(aes(width = .9), color = "grey20") +
  scale_fill_identity() +
  scale_y_discrete(labels = str_remove(ylabs, "ME")) +
  theme_minimal() +
  ylab("Groups of co-expressed genes") +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.grid = element_blank())

clu + p +
  patchwork::plot_layout(ncol = 2, widths = c(0.05, 1))
```

<br>
<br>

***

<br>
<br>

#### Modules vs. Biological functions

Genes are further clustered by biological functions and the results of this grouping are represented along patterns of up/down-regulation and co-expression:  
-- **Down-regulated**:  
  -- **Blue module**:  
    -- component c3b tandem duplicate 2,  
    -- ETS domain-containing TF ERF-like,  
    -- peptidyl-prolyl cis-trans isomerase FKBP9-like,  
  -- **Pink module**:  
    -- NADH: ubiquinone oxidoreductase subunit B9,  
    -- component c3b tandem duplicate 2

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=8}
sig_down <- sigDE$gene[sigDE$log2FoldChange<0]
moduleMembership <- data.frame(GeneId = colnames(subExpr),
                               Module = mergedColors) %>%
  dplyr::mutate(Regulated = ifelse(GeneId %in% sig_down, "down", "up"))

bipart <- sigDE %>% 
  dplyr::select(gene, external_gene_name, go_id) %>%
  dplyr::mutate(color = moduleMembership$Module[match(gene, moduleMembership$GeneId)],
                shape = moduleMembership$Regulated[match(gene, moduleMembership$GeneId)]) %>%
  dplyr::filter(!duplicated(gene, go_id),
                external_gene_name != "",
                go_id != "")

bigraph <- igraph::graph_from_data_frame(bipart[,c("external_gene_name", "go_id")])
lll     <- na.omit(match(names(igraph::V(bigraph)), bipart$external_gene_name))
igraph::V(bigraph)$type  <- names(igraph::V(bigraph)) %in% bipart$external_gene_name
igraph::V(bigraph)$color <- ifelse(igraph::V(bigraph)$type==FALSE, "grey60",  bipart$color[lll])
igraph::V(bigraph)$shape <- ifelse(igraph::V(bigraph)$type==FALSE, "rectangle", 
                                   c("circle","square")[as.numeric(as.factor(bipart$shape[lll]))])

Iadj    <- bigraph %>% as_incidence_matrix()
go_ids  <- rownames(Iadj)[which(rowSums(Iadj) > 5)]
ext_gen <- colnames(Iadj)[which(colSums(Iadj) > 0)]
bipart  <- bipart %>% dplyr::filter(external_gene_name %in% ext_gen, go_id %in% go_ids) %>% dplyr::mutate(freq = 1)

bipart$gene <- as.factor(bipart$gene)
bipart$desc <- sigDE$description[match(bipart$go_id, sigDE$go_id)] %>%
  stringr::str_remove(pattern = "Source.*") %>% 
  stringr::str_remove(pattern = fixed(" ["))
bipart$desc[bipart$desc=="complement component c3b, tandem duplicate 2"] <- "component c3b\ntandem duplicate 2"
bipart$desc[bipart$desc=="ETS domain-containing transcription factor ERF-like"] <- "ETS domain-containing\nTF ERF-like"
bipart$desc[bipart$desc=="NADH:ubiquinone oxidoreductase subunit B9"] <- "NADH: ubiquinone\noxidoreductase\nsubunit B9"
bipart$desc[bipart$desc=="peptidyl-prolyl cis-trans isomerase FKBP9-like"] <- "peptidyl-prolyl cis-trans\nisomerase FKBP9-like"

StatStratum <- ggalluvial::StatStratum

p <- ggplot(bipart,
       aes(y     = freq, 
           #axis1 = external_gene_name, 
           axis1 = shape, 
           axis2 = color,
           axis3 = desc)) +
  ggalluvial::geom_alluvium(aes(fill = color), width = 1/3, knot.pos = 0.2) +
  ggalluvial::geom_stratum(width = 1/3, 
                           color = "grey20", 
                           fill  = "white", 
                           alpha = .70) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_fill_manual(values = c(black     = "black",     blue   = "#81B0E4",   brown = "#70493D",
                               green     = "#3F752B",   pink   = "lightpink", red   = "red4", 
                               turquoise = "lightblue", yellow = "gold")) +
  scale_x_continuous(breaks = 1:3, labels = c("Regulation\ntrend", 
                                              "Co-expression\nmodules", 
                                              "Gene Ontology\nTerms")) +
  guides(fill = "none") +
  ggtitle("Co-expressed genes and associated biological functions") +
  ggpubr::theme_pubclean() +
  theme(axis.text.y  = element_blank(),
        axis.ticks   = element_blank(),
        axis.title.y = element_blank())
p
```

<br>
<br>

***

<br>
<br>

# Enriched Gene Ontology 

The GO enrichment analysis is performed using the g:Profiler tool (v.1.2., "http://biit.cs.ut.ee/gprofiler/") which bases its Gene Ontology on the Ensembl Database. Graphs are simplified to allow easy inspection but may prevent relevant GO terms to display. 

**We can refine the graphs together if you need.**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gprofiler2::get_version_info("saurata")
```

## Up-regulated genes {.tabset}

### Manhattan plot
*The graph is interactive. Hover your mouse to see the details of each GO term.*

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10}
sources <- c("GO", "REAC", "MIRNA", "CORUM", "HPA", "WP", "KEGG")
gprofiler_res_up <- gprofiler2::gost(
  query             = as.vector(na.omit(sigDE_up)), 
  organism          = "saurata",
  ordered_query     = F, 
  exclude_iea       = F, 
  correction_method = "fdr",
  custom_bg         = genes$entrezgene_id,
  evcodes           = TRUE,
  sources           = sources) 

ordered_sig <- gprofiler_res_up$result %>%
  dplyr::arrange(p_value) %>%
  dplyr::select(term_id) %>%
  as.vector()

gprofiler2::gostplot(gostres = gprofiler_res_up, interactive = TRUE)
```

<br>
<br>

### Table

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gprofiler_res_up$result %>%
  as.data.frame() %>%
  dplyr::select(
    source,
    term_id,
    term_name,
    term_size,
    query_size,
    intersection_size,
    effective_domain_size,
    source_order,
    parents
  )
```

<br>
<br>

### Graph
*The graph is interactive. Zoom in and out, move the dots around.*

Pink nodes represent enriched GO terms as detected by the g:Profiler tool. Each GO term node carries its name as defined in the Ensembl Database. Black nodes are the differentially expressed genes detected in the DESeq analysis which relate to the GO term they are connected to.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gem <- gprofiler_res_up$result %>%
  dplyr::select(term_id, term_name, p_value, intersection) %>%
  dplyr::rename("GO.ID"="term_id", "Description"="term_name", "p.Val"="p_value", "Genes"="intersection") %>%
  dplyr::mutate(FDR = p.Val, Phenotype = "+1") %>%
  dplyr::select(GO.ID, Description, p.Val, FDR, Phenotype, Genes) %>%
  dplyr::mutate(Genes2 = strsplit(Genes, ",")) %>%
  tidyr::unnest(cols = c("Genes2")) %>%
  as.data.frame()

gem_graph <- igraph::graph_from_data_frame(gem[,c("GO.ID", "Genes2")], directed = FALSE)
gem_graph <- igraph::simplify(gem_graph)
lll       <- na.omit(match(names(igraph::V(gem_graph)), gem$Genes2))
igraph::V(gem_graph)$type  <- (names(igraph::V(gem_graph)) %in% gem$Genes2)
igraph::V(gem_graph)$color <- ifelse(igraph::V(gem_graph)$type==FALSE, "lightpink", "grey50")
igraph::V(gem_graph)$shape <- ifelse(igraph::V(gem_graph)$type==FALSE, "circle","circle")

gem_mst <- igraph::mst(gem_graph)
com_mst <- fastgreedy.community(gem_mst)
Iadj    <- gem_mst %>% as_incidence_matrix()
go_ids  <- rownames(Iadj)[which(rowSums(Iadj) <= 1)]
ext_gen <- colnames(Iadj)[which(colSums(Iadj) == 0)]
gem_mst <- delete.vertices(gem_mst, v = c(go_ids, ext_gen))
lls <-  which(!is.na(stringr::str_extract(names(V(gem_mst)), "GO")))
nns <- length(names(V(gem_mst))) - length(lls)
V(gem_mst)$label <- c(gem$Description[match(names(V(gem_mst))[lls], gem$GO.ID)], rep("", nns))

vN <- visNetwork::visIgraph(gem_mst) %>%
  visNetwork::visIgraphLayout("layout.fruchterman.reingold") %>% 
  visNetwork::visNodes(font = list(size = 10))
vN$x$nodes$label <- V(gem_mst)$label
vN$x$nodes$color <- V(gem_mst)$color
vN$x$edges$color <- "grey40"
vN$x$nodes$border.color <- "black"

vN
```

<br>
<br>

## Down-regulated genes {.tabset}

### Manhattan plot
*The graph is interactive. Hover your mouse to see the details of each GO term.*

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10}
sources <- c("GO", "REAC", "MIRNA", "CORUM", "HPA", "WP", "KEGG")
gprofiler_res_do <- gprofiler2::gost(
  query             = as.vector(na.omit(sigDE_do)), 
  organism          = "saurata",
  ordered_query     = F, 
  exclude_iea       = F, 
  correction_method = "fdr",
  custom_bg         = genes$entrezgene_id,
  evcodes           = TRUE,
  sources           = sources) 

ordered_sig <- gprofiler_res_do$result %>%
  dplyr::arrange(p_value) %>%
  dplyr::select(term_id) %>%
  as.vector()

gprofiler2::gostplot(gostres = gprofiler_res_do, interactive = TRUE)
```

<br>
<br>

***

<br>
<br>

### Table

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gprofiler_res_do$result %>%
  as.data.frame() %>%
  dplyr::select(
    source,
    term_id,
    term_name,
    term_size,
    query_size,
    intersection_size,
    effective_domain_size,
    source_order,
    parents
  )
```

<br>
<br>

***

<br>
<br>

### Graph

*The graph is interactive. Zoom in and out, move the dots around.*

Pink nodes represent enriched GO terms as detected by the g:Profiler tool. Each GO term node carries its name as defined in the Ensembl Database. Black nodes are the differentially expressed genes detected in the DESeq analysis which relate to the GO term they are connected to.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
gem <- gprofiler_res_do$result %>%
  dplyr::select(term_id, term_name, p_value, intersection) %>%
  dplyr::rename("GO.ID"="term_id", "Description"="term_name", "p.Val"="p_value", "Genes"="intersection") %>%
  dplyr::mutate(FDR = p.Val, Phenotype = "+1") %>%
  dplyr::select(GO.ID, Description, p.Val, FDR, Phenotype, Genes) %>%
  dplyr::mutate(Genes2 = strsplit(Genes, ",")) %>%
  tidyr::unnest(cols = c("Genes2")) %>%
  as.data.frame()

gem_graph <- igraph::graph_from_data_frame(gem[,c("GO.ID", "Genes2")], directed = FALSE)
gem_graph <- igraph::simplify(gem_graph)
lll       <- na.omit(match(names(igraph::V(gem_graph)), gem$Genes2))
igraph::V(gem_graph)$type  <- (names(igraph::V(gem_graph)) %in% gem$Genes2)
igraph::V(gem_graph)$color <- ifelse(igraph::V(gem_graph)$type==FALSE, "lightpink", "grey50")
igraph::V(gem_graph)$shape <- ifelse(igraph::V(gem_graph)$type==FALSE, "circle","circle")

gem_mst <- igraph::mst(gem_graph)
com_mst <- fastgreedy.community(gem_mst)
Iadj    <- gem_mst %>% as_incidence_matrix()
go_ids  <- rownames(Iadj)[which(rowSums(Iadj) <= 1)]
ext_gen <- colnames(Iadj)[which(colSums(Iadj) == 0)]
gem_mst <- delete.vertices(gem_mst, v = c(go_ids, ext_gen))
lls <-  which(!is.na(stringr::str_extract(names(V(gem_mst)), "GO")))
nns <- length(names(V(gem_mst))) - length(lls)
V(gem_mst)$label <- c(gem$Description[match(names(V(gem_mst))[lls], gem$GO.ID)], rep("", nns))

vN <- visNetwork::visIgraph(gem_mst) %>%
  visNetwork::visIgraphLayout("layout.fruchterman.reingold") %>% 
  visNetwork::visNodes(font = list(size = 10))
vN$x$nodes$label <- V(gem_mst)$label
vN$x$nodes$color <- V(gem_mst)$color
vN$x$edges$color <- "grey40"
vN$x$nodes$border.color <- "black"

vN
```


<br>
<br>

***

<br>
<br>

# Enriched KEGG pathway {.tabset}

*Coming soon!*

## Plot

<br>
<br>

***

<br>
<br>


